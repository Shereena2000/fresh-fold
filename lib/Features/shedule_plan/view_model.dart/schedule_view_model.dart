import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import '../model/schedule_model.dart';
import '../repository/schedule_repository.dart';

class ScheduleViewModel extends ChangeNotifier {
  final ScheduleRepository _repository = ScheduleRepository();

  bool _isLoading = false;
  String? _errorMessage;
  String? _successMessage;
  List<ScheduleModel> _schedules = [];
  ScheduleModel? _currentSchedule;

  // Getters
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  String? get successMessage => _successMessage;
  List<ScheduleModel> get schedules => _schedules;
  ScheduleModel? get currentSchedule => _currentSchedule;

  // Form data
  String? _selectedServiceType;
  String? _selectedWashType;
  String? _selectedLocation;
  LatLng? _selectedLatLng;
  DateTime? _selectedDate;
  String? _selectedTimeSlot;

  String? get selectedServiceType => _selectedServiceType;
  String? get selectedWashType => _selectedWashType;
  String? get selectedLocation => _selectedLocation;
  LatLng? get selectedLatLng => _selectedLatLng;
  DateTime? get selectedDate => _selectedDate;
  String? get selectedTimeSlot => _selectedTimeSlot;

  // ==================== SETTERS ====================

  void setServiceType(String? value) {
    _selectedServiceType = value;
    notifyListeners();
  }

  void setWashType(String? value) {
    _selectedWashType = value;
    notifyListeners();
  }

  void setLocation(String location, LatLng? latLng) {
    _selectedLocation = location;
    _selectedLatLng = latLng;
    notifyListeners();
  }

  void setDate(DateTime? date) {
    _selectedDate = date;
    notifyListeners();
  }

  void setTimeSlot(String? timeSlot) {
    _selectedTimeSlot = timeSlot;
    notifyListeners();
  }

  // ==================== VALIDATION ====================

  bool _validateScheduleData() {
    if (_selectedLocation == null || _selectedLocation!.isEmpty) {
      _errorMessage = 'Please select a pickup location';
      notifyListeners();
      return false;
    }

    if (_selectedDate == null) {
      _errorMessage = 'Please select a pickup date';
      notifyListeners();
      return false;
    }

    if (_selectedTimeSlot == null || _selectedTimeSlot!.isEmpty) {
      _errorMessage = 'Please select a time slot';
      notifyListeners();
      return false;
    }

    if (_selectedServiceType == null || _selectedServiceType!.isEmpty) {
      _errorMessage = 'Please select a service type';
      notifyListeners();
      return false;
    }

    if (_selectedWashType == null || _selectedWashType!.isEmpty) {
      _errorMessage = 'Please select a wash type';
      notifyListeners();
      return false;
    }

    // Check if date is in the past
    DateTime now = DateTime.now();
    DateTime selectedDateTime = DateTime(
      _selectedDate!.year,
      _selectedDate!.month,
      _selectedDate!.day,
    );
    DateTime today = DateTime(now.year, now.month, now.day);

    if (selectedDateTime.isBefore(today)) {
      _errorMessage = 'Please select a future date';
      notifyListeners();
      return false;
    }

    return true;
  }

  // ==================== CREATE SCHEDULE ====================

  Future<bool> createSchedule(String userId) async {
    if (!_validateScheduleData()) {
      return false;
    }

    _isLoading = true;
    _errorMessage = null;
    _successMessage = null;
    notifyListeners();

    try {
      ScheduleModel schedule = ScheduleModel(
        scheduleId: '', // Will be auto-generated by Firebase
        userId: userId,
        serviceType: _selectedServiceType!,
        washType: _selectedWashType!,
        pickupLocation: _selectedLocation!,
        latitude: _selectedLatLng?.latitude,
        longitude: _selectedLatLng?.longitude,
        pickupDate: _selectedDate!,
        timeSlot: _selectedTimeSlot!,
        status: 'pending',
        createdAt: DateTime.now(),
      );

      String scheduleId = await _repository.createSchedule(schedule);
      _successMessage = 'Schedule created successfully!';
      _currentSchedule = schedule.copyWith(scheduleId: scheduleId);

      // Clear form data after successful creation
      clearFormData();

      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _errorMessage = 'Failed to create schedule: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  // ==================== FETCH SCHEDULES ====================

  Future<void> loadUserSchedules(String userId) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      _schedules = await _repository.getUserSchedules(userId);
      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to load schedules: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
    }
  }
Future<void> loadScheduleById(String userId, String scheduleId) async {
  _isLoading = true;
  _errorMessage = null;
  notifyListeners();

  try {
    _currentSchedule = await _repository.getScheduleById(userId, scheduleId);
    _isLoading = false;
    notifyListeners();
  } catch (e) {
    _errorMessage = 'Failed to load schedule: ${e.toString()}';
    _isLoading = false;
    notifyListeners();
  }
}

  Future<void> loadUpcomingSchedules(String userId) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      _schedules = await _repository.getUpcomingSchedules(userId);
      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to load upcoming schedules: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> loadScheduleHistory(String userId) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      _schedules = await _repository.getScheduleHistory(userId);
      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to load schedule history: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> loadSchedulesByStatus(String userId, String status) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      _schedules = await _repository.getUserSchedulesByStatus(userId, status);
      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'Failed to load schedules: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
    }
  }

  // ==================== UPDATE SCHEDULE ====================

 Future<bool> updateScheduleStatus(String userId, String scheduleId, String status) async {
  _isLoading = true;
  _errorMessage = null;
  notifyListeners();

  try {
    await _repository.updateScheduleStatus(userId, scheduleId, status);
    _successMessage = 'Schedule updated successfully';
    
    if (_currentSchedule?.scheduleId == scheduleId) {
      _currentSchedule = _currentSchedule!.copyWith(
        status: status,
        updatedAt: DateTime.now(),
      );
    }

    _isLoading = false;
    notifyListeners();
    return true;
  } catch (e) {
    _errorMessage = 'Failed to update schedule: ${e.toString()}';
    _isLoading = false;
    notifyListeners();
    return false;
  }
}

  Future<bool> cancelSchedule(String userId, String scheduleId) async {
  return await updateScheduleStatus(userId, scheduleId, 'cancelled');
}

Future<bool> deleteSchedule(String userId, String scheduleId) async {
  _isLoading = true;
  _errorMessage = null;
  notifyListeners();

  try {
    await _repository.deleteSchedule(userId, scheduleId);
    _schedules.removeWhere((schedule) => schedule.scheduleId == scheduleId);
    _successMessage = 'Schedule deleted successfully';
    _isLoading = false;
    notifyListeners();
    return true;
  } catch (e) {
    _errorMessage = 'Failed to delete schedule: ${e.toString()}';
    _isLoading = false;
    notifyListeners();
    return false;
  }
}


  // ==================== STREAM SCHEDULES ====================

  Stream<List<ScheduleModel>> streamUserSchedules(String userId) {
    return _repository.streamUserSchedules(userId);
  }

  // ==================== SYNC TO GLOBAL COLLECTION ====================

  /// Sync user's schedules to global collection (for migration/fixing sync issues)
  Future<bool> syncSchedulesToGlobal(String userId) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      await _repository.syncUserSchedulesToGlobal(userId);
      _successMessage = 'Schedules synced successfully';
      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _errorMessage = 'Failed to sync schedules: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  // ==================== UTILITY METHODS ====================

  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }

  void clearSuccess() {
    _successMessage = null;
    notifyListeners();
  }

  void clearFormData() {
    _selectedServiceType = null;
    _selectedWashType = null;
    _selectedLocation = null;
    _selectedLatLng = null;
    _selectedDate = null;
    _selectedTimeSlot = null;
    notifyListeners();
  }

  void clearAll() {
    _isLoading = false;
    _errorMessage = null;
    _successMessage = null;
    _schedules = [];
    _currentSchedule = null;
    clearFormData();
    notifyListeners();
  }

  // ==================== HELPER METHODS ====================

  String getServiceTypeLabel(String serviceType) {
    switch (serviceType) {
      case 'regular':
        return 'Regular (2-3 Days)';
      case 'express':
        return 'Express (24 Hours)';
      case 'premium':
        return 'Premium (Same Day)';
      default:
        return serviceType;
    }
  }

  String getWashTypeLabel(String washType) {
    switch (washType) {
      case 'dry_clean':
        return 'Dry Cleaning & Steam Press';
      case 'wash_press':
        return 'Wash & Steam Press';
      case 'press_only':
        return 'Steam Press Only';
      default:
        return washType;
    }
  }

  String getStatusLabel(String status) {
    switch (status) {
      case 'pending':
        return 'Pending';
      case 'confirmed':
        return 'Confirmed';
      case 'picked_up':
        return 'Picked Up';
      case 'processing':
        return 'Processing';
      case 'ready':
        return 'Ready for Delivery';
      case 'delivered':
        return 'Delivered';
      case 'cancelled':
        return 'Cancelled';
      default:
        return status;
    }
  }
}